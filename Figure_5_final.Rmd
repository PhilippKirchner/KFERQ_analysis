---
title: "Figure_5"
output: html_document
---

This markdown file contains the necessary code to to generate the data and diagrams for Figure 5 and S5
Several files generated in the markdown for Figure 1 are necessary to run these scripts

For the functional analysis of CMA motif containing proteins a custom set of GO terms was specified. Starting from the generic GO-slim database available from the GO consortium, cellular processes were chosen to represent all major cellular pathways.
To improve annotation density for the chosen terms all their child term annotation were mapped to the parents using the map2slim algorithm (http://go.princeton.edu/cgi-bin/GOTermMapper)

```{r read file of mapped GO terms}
#The actual names for the GO terms are stored in a separate file
slimTerms <- read.csv("raw_data/newGO_custom_names.csv",header=F,stringsAsFactors = F)
colnames(slimTerms) <- c("GO","names")
mappedGOs <- read.table("raw_data/map2slim_output_tsv.txt",sep="\t",header=T,stringsAsFactors = F)
```

```{r converting the mapped table}
#The mapping algorithm returned a list of genes for each term
#This information is used to generate an annotation file for the enrichment analysis
CMA.customGO <- left_join(all.prot, select(CMA.protRel, -Length), by = "Entry")
CMA.customGO$topGroups[is.na(CMA.customGO$topGroups)] <- "no_motif"
CMA.customGO$indiGroups[is.na(CMA.customGO$indiGroups)] <- "no_motif"

for (i in 1:nrow(slimTerms)){
  CMA.customGO <- eval(parse(text=paste0("CMA.customGO %>% mutate(`",eval(mappedGOs$GOID[i]),"` = ifelse(CMA.customGO$Entry %in% unlist(str_split(mappedGOs$ANNOTATED_GENES[i], boundary(\"word\"))),1,0))")))
}
```

The probability of enrichment for each GO term is calculated using Fisher's exact Test.

The present code uses the topGroups (where proteins are grouped according to the highest ranking motif they harbor)
For other groupings the respective column has to be selected as a grouping variable.
The column indiGroups displays all knind of motifs occurring in a protein)
Later the fractional content of proteins is used (this particular column is not generated by default)

```{r generate contigency tables}
getContingency <- function(GO,grouping, dataSet){
  #for the contingency tables the following variables are used:
  #in category: proteins with a KGERQ-like motif in the GO term
  #not_in_category: protein with a KFERQ-like motif not in the GO term
  #n_category: proteins without a KFERQ-like motif in the GO trem
  #n_outside_category: proteins without a KFERQ-like motif not in the GO term
colnames(dataSet)[colnames(dataSet) == grouping] <- "group" 
eval(parse(text=paste0("dataSet %>%
                         group_by(group) %>% 
                         summarise(n = n(),in_category = sum(`",eval(GO),"`)) %>% 
                         mutate(not_in_category = n-in_category,
                         n_category=sum(CMA.customGO$`",eval(GO),"`)-in_category,
                         n_outside_category=nrow(CMA.customGO)-in_category-n_category-not_in_category)")))
}
#The variable "grouping" tells the function which grouping variable to use
contiTable<-setNames(parallel::mclapply(slimTerms$GO,getContingency,grouping = "topGroups", dataSet = CMA.customGO, mc.cores=2),slimTerms$GO)
```

```{r fisher tests}
getFTest <- function(conti){
  result<-fisher.test(matrix(unlist(conti),2))
  c(pValue=result$p.value,OR=result$estimate)
}

makeFTlist<-function(GO, dataSet){
eval(parse(text=paste0("dataSet$`",eval(GO),"` %>% rowwise() %>% mutate(pValue = getFTest(c(in_category,not_in_category,n_category,n_outside_category))[[1]],
                                   OR = getFTest(c(in_category,not_in_category,n_category,n_outside_category))[[2]])")))
  
}
FTresults <- rbindlist(setNames(parallel::mclapply(slimTerms$GO,makeFTlist, dataSet = contiTable, mc.cores=2),slimTerms$GO),idcol = "GO")
```

```{r z-score wrapper}
#in addition to the Fisher tests also z-scores are calculated
#To keep results consistent between runs the random seed is fixed before each run of the random draws
#without this the same category in two different runs may have small differences in the scores
getZscores <- function(who, grouping, dataSet){
  #This allows for different ways of grouping the data
  colnames(dataSet)[colnames(dataSet) == grouping] <- "group" 
  subSet <- eval(parse(text=paste0("dataSet %>% filter(group == \"",eval(who),"\")")))
  #The seed is set here to ensure the same result for set of proteins independently of the order that the sets are calculated
  set.seed(123)
  rndSetOutput <- rbindlist(setNames(lapply(slimTerms$GO,function(GO){
    rndList <- rbindlist(lapply(seq_len(40),function(x){
      eval(parse(text=paste0("CMA.customGO %>% sample_n(nrow(subSet)) %>% summarise(in_category = sum(`",eval(GO),"`))")))
      }))
    rndList <- rndList %>%  summarise(in_category_mean = mean(in_category), in_category_sd = sd(in_category)) %>% select(in_category_mean,in_category_sd)   
    }),slimTerms$GO),idcol="GO")
  
  return(rndSetOutput)
}

GOzScores <- rbindlist(setNames(lapply(c("canon","phos","Konly","no_motif"),getZscores,grouping = "topGroups", dataSet=CMA.customGO),c("canon","phos","Konly","no_motif")),idcol="group")

FTresults <- left_join(FTresults, GOzScores, by = c("group","GO"))

FTresults <- FTresults %>% mutate(zScore = (in_category-in_category_mean)/in_category_sd)
FTresults <- left_join(FTresults, slimTerms, by ="GO")

```

```{r combining results and saving}
FTresults <- FTresults %>% mutate(combinedScore = -log(pValue)*zScore)
write.table(FTresults,"customGO_pz_top_groups.txt", sep ="\t", row.names = F)
```

```{r plotting top hits using the combined score}
#The chosen classes are automatically put into one plot with empty entries added for spacing
makeTopGO_bar <- function(classes, toShow =5){
  #The first 5 positive hits of each group are isolated for plotting 
  makePlotData <- function(class){
    subSet <- eval(parse(text=paste0("FTresults %>% filter(group == \"", eval(class),"\")")))
    topRich <- subSet %>% arrange(desc(combinedScore))
    topRich <- topRich[c(1:toShow),]
    topRich <- topRich %>% filter(combinedScore > 0) %>% select(names, combinedScore)
    topRich[nrow(topRich)+1,] <- c(class, 0)
    return(topRich)
  }
  plotData <- rbindlist(lapply(classes,makePlotData))
  plotData <- plotData[c(1:nrow(plotData)-1),]
  plotData$xAxis <- paste("GO",sprintf("%02d",seq_len(nrow(plotData))))
  xAxisLabels <- plotData$names[1:nrow(plotData)]
  plotData <- plotData %>% mutate(combinedScore = as.numeric(combinedScore))
  
  #The scales will be log transformed and as a result the values <= 0 will appear as -inf to avois this all values are +1
  plot <- ggplot(plotData, aes(x= xAxis, y= combinedScore+1)) + geom_bar(stat="identity", position = position_dodge(), fill = "grey20") + theme_classic() + scale_y_continuous(expand= c(0,0), trans="log10") + scale_x_discrete(expand = c(0.06,0), labels = xAxisLabels) + coord_cartesian(ylim = c(1,max(plotData$combinedScore))) + annotation_logticks(sides="l") + labs(y = "combined score") + theme(axis.title.x = element_blank(), axis.title.y = element_text(size=9), axis.text.x = element_text(color= "black", size = 7, angle = 45, hjust = 1, vjust=1.03  ), axis.text.y = element_text(color="black"), axis.ticks.x = element_blank()) 
  return(plot)
}

ggsave("images/topGroups.pdf", makeTopGO_bar(classes = c("canon","phos","Konly","no_motif")) , height = 2.8 , width = 5, device="pdf")
```

For the triangle plots the fractional content is used to classify the proteins into samller groups.
The fraction of canonical (canoFrac), phos. act. (phosFrac) and acetyl. act. (KFrac) is binned in 5% increments.
Due to the nature of projecting a 3D space into 2D using the triangle plot some groups cannot be displayed.
The groups to be used are found in the file "ratios_list.json"

```{r annotation for all triangle plot groups}
#This script removes all empty elements from the list to avoid potential trouble with the calculations
triangleBins <-  fromJSON("raw_data/ratios_list.json")
splitByTriangle <- function(x){
  if (length(triangleBins[[x]])> 0)
    data.frame(triaGroups = names(triangleBins[x]), Entry = triangleBins[[x]])
  else
    data.frame(triaGroups = names(triangleBins[x]), Entry = "EMPTY")
}
triangleBins <- rbindlist(lapply(seq_len(length(triangleBins)),splitByTriangle))
triangleBins <- triangleBins %>% filter(!(Entry == "EMPTY"))
CMA.customGO <- left_join(triangleBins, CMA.customGO, by = "Entry")
```

In some cases it will be interesting to see enrichment results for differnt groups.
For example in figure 2 a list of proteins was extracted where the canonical motif was localized in a region of relatively high disorder

```{r calculating enrichments for custom lists}
meanDis <- read.table("onlyOneCanon_disorder.txt", header = T, stringsAsFactors = F)
meanDis <- meanDis %>% mutate(relDis = meanDisRegion/meanDisAll)
filterVector <- meanDis %>% filter(relDis >1.2, meanDisRegion > 0.3) %>% select(Entry) %>% unlist(.)

subSet <- CMA.customGO %>% filter(Entry %in% filterVector)
subSet$customGroups <- "highDis"
  
contiTable<-setNames(parallel::mclapply(slimTerms$GO,getContingency,grouping = "customGroups", dataSet = subSet, mc.cores=2),slimTerms$GO)
  
FTresults <- rbindlist(setNames(parallel::mclapply(slimTerms$GO,makeFTlist, dataSet = contiTable, mc.cores=2),slimTerms$GO),idcol = "GO")
  
GOzScores <- rbindlist(setNames(lapply(levels(factor(subSet$customGroups)),getZscores,grouping = "customGroups", dataSet=subSet),levels(factor(subSet$customGroups))),idcol="group")

GOzScores <- GOzScores %>% mutate(zScore = (in_category-in_category_mean)/in_category_sd)
GOzScores <- left_join(GOzScores, slimTerms, by ="GO")

GOzScoresFT <- left_join(FTresults,GOzScores, by = c("GO","group"))
GOzScoresFT <- GOzScoresFT %>% mutate(combinedScore = -log(pValue)*zScore)

ggsave("images/highDis.pdf", makeTopGO_bar(classes = levels(factor(subSet$customGroups))) , height = 3 , width = 3.5, device="pdf")
```

In addition to the grouping by top ranking motif all individual groupings of motifs are tested for enrichment

```{r enrichment for the individual groups}
contiTable<-setNames(parallel::mclapply(slimTerms$GO,getContingency,grouping = "indiGroups", dataSet = CMA.customGO, mc.cores=2),slimTerms$GO)
  
FTresults <- rbindlist(setNames(parallel::mclapply(slimTerms$GO,makeFTlist, dataSet = contiTable, mc.cores=2),slimTerms$GO),idcol = "GO")
  
GOzScores <- rbindlist(setNames(lapply(levels(factor(CMA.customGO$indiGroups)),getZscores,grouping = "indiGroups", dataSet=CMA.customGO),levels(factor(CMA.customGO$indiGroups))),idcol="group")

FTresults <- left_join(FTresults,GOzScores, by = c("GO","group"))
FTresults <- left_join(FTresults, slimTerms, by ="GO")
FTresults <- FTresults %>% mutate(zScore = (in_category-in_category_mean)/in_category_sd)
FTresults <- FTresults %>% mutate(combinedScore = -log(pValue)*zScore)

write.table(FTresults,"customGO_pz_indi_groups.txt", sep ="\t", row.names = F)

ggsave("images/indiGroups.pdf", makeTopGO_bar(classes = c("canonly","canoPhos","canoK","canoPhosK","phonly","phosK","Konly")) , height = 3 , width = 6, device="pdf")
```

The annotation density for different groups can be compared

```{r comparing annotation densities}
GODensity <- all.prot  %>% group_by(Entry) %>% summarise(GOnumber = length(unlist(gregexpr(":",`Gene ontology (GO)`)))) 
GODensity <- left_join(GODensity,select(all.prot,Entry,Status,`Gene ontology (GO)`), by ="Entry")
GODensity$GOnumber <- ifelse(nchar(GODensity$`Gene ontology (GO)`)==0,0,GODensity$GOnumber)

GODensity <- left_join(GODensity, select(CMA.protRel, Entry, topGroups), by = "Entry")
GODensity$topGroups[is.na(GODensity$topGroups)] <- "no_motif"
```

```{r plots}
GODensity$topGroups <- factor(GODensity$topGroups, levels = c("canonical","phosphorylation","acetylation","no_motif"))

GOboxKind <- ggplot(GODensity,aes(y=GOnumber,x=topGroups)) + geom_boxplot(outlier.size = NA) + stat_summary(fun.y =mean, color = "black",geom = "point", shape = 18, size = 1.5, show_guide=F)+ theme_classic() + theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1,size=9, color = "black"),axis.text.y=element_text(size=9,color="black"), plot.title = element_text(size=10),axis.title.x = element_text(size=9),axis.title.y = element_text(size=9)) + coord_cartesian(ylim=c(0,35))  +labs(y = "n of GO terms / protein ", x = element_blank())
ggsave("GOdensity_Kind_Status.pdf", GOboxKind, height=2, width = 1.75, device = "pdf")
```